1348.399576 ,
1353.409576 ,
1358.419576 ,
1363.429576 ,
1368.4395760000002 ,
1373.449576 ,
1378.449576 ,
1383.459576 ,
1388.4695760000002 ,
1393.479576 ,
1398.489576 ,
1403.499576 ,
1408.509576 ,
1413.5095760000002 ,
1418.519576 ,
1423.529576 ,
1428.539576 ,
1433.5495760000001 ,
1438.559576 ,
1443.569576 ,
1448.579576 ,
1453.579576 ,
1458.589576 ,
1463.599576 ,
1468.609576 ,
1473.6195759999998 ,
1478.6295759999998 ,
1483.639576 ,
1488.639576 ,
1493.649576 ,
1498.659576 ,
1503.669576 ,
1508.679576 ,
1513.689576 ,
1518.699576 ,
1523.709576 ,
1528.709576 ,
1533.719576 ,
1538.729576 ,
1543.739576 ,
1548.7495760000002 ,
1553.759576 ,
1558.769576 ,
1563.7695760000001 ,
1568.7795760000001 ,
1573.7895760000001 ,
1578.799576 ,
1583.8095759999999 ,
1588.8195759999999 ,
1593.829576 ,
1598.839576 ,
1603.8395759999999 ,
1608.8495759999998 ,
1613.859576 ,
1618.869576 ,
1623.879576 ,
1628.889576 ,
1633.8995759999998 ,
1638.899576 ,
1643.909576 ,
1648.919576 ,
1653.929576 ,
1658.939576 ,
1663.949576 ,
1668.959576 ,
1673.969576 ,
1678.969576 ,
1683.979576 ,
1688.989576 ,
1693.999576 ,
1699.009576 ,
1704.0195760000001 ,
1709.0295760000001 ,
1714.029576 ,
1719.039576 ,
1724.0495760000001 ,
1729.059576 ,
1734.069576 ,
1739.0795759999999 ,
1744.0895759999999 ,
1749.099576 ,
1754.099576 ,
1759.109576 ,
1764.1195759999998 ,
1769.129576 ,
1774.139576 ,
1779.149576 ,
1784.159576 ,
1789.159576 ,
1794.169576 ,
1799.179576 ,
1804.189576 ,
1809.199576 ,
1814.2095760000002 ,
1819.219576 ,
1824.229576 ,
1829.229576 ,
1834.2395760000002 ,
1839.2495760000002 ,
1844.259576 ,
1849.269576 ,
1854.279576 ,
1859.2895760000001 ,
1864.2995760000001 ,
1869.299576 ,
1874.3095759999999 ,
1879.319576 ,
1884.329576 ,
1889.339576 ,
1894.349576 ,
1899.3595759999998 ,
1904.359576 ,
1909.369576 ,
1914.379576 ,
1919.389576 ,
1924.3995759999998 ,
1929.409576 ,
1934.419576 ,
1939.429576 ,
1944.429576 ,
1949.439576 ,
1954.449576 ,
1959.459576 ,
1964.469576 ,
1969.479576 ,
1974.4895760000002 ,
1979.489576 ,
1984.499576 ,
1989.509576 ,
1994.5195760000001 ,
1999.5295760000001 ,
2004.539576 ,
2009.549576 ,
2014.5595759999999 ,
2019.5595759999999 ,
2024.569576 ,
2029.579576 ,
2034.589576 ,
2039.599576 ,
2044.609576 ,
2049.619576 ,
2054.619576 ,
2059.629576 ,
2064.639576 ,
2069.6495760000003 ,
2074.659576 ,
2079.6695760000002 ,
2084.679576 ,
2089.689576 ,
2094.6895759999998 ,
2099.699576 ,
2104.7095759999997 ,
2109.719576 ,
2114.729576 ,
2119.7395760000004 ,
2124.749576 ,
2129.749576 ,
2134.759576 ,
2139.769576 ,
2144.779576 ,
2149.7895759999997 ,
2154.799576 ,
2159.8095759999997 ,
2164.8195760000003 ,
2169.819576 ,
2174.829576 ,
2179.839576 ,
2184.849576 ,
2189.859576 ,
2194.869576 ,
2199.879576 ,
2204.8795760000003 ,
2209.889576 ,
2214.8995760000003 ,
2219.909576 ,
2224.9195760000002 ,
2229.929576 ,
2234.9395759999998 ,
2239.949576 ,
2244.949576 ,
2249.959576 ,
2254.969576 ,
2259.979576 ,
2264.989576 ,
2269.999576 ,
2275.009576 ,
2280.009576 ,
2285.0195759999997 ,
2290.029576 ,
2295.039576 ,
2300.0495760000003 ,
2305.059576 ,
2310.069576 ,
2315.079576 ,
2320.079576 ,
2325.089576 ,
2330.0995759999996 ,
2335.109576 ,
2340.119576 ,
2345.1295760000003 ,
2350.139576 ,
2355.139576 ,
2360.149576 ,
2365.159576 ,
2370.169576 ,
2375.179576 ,
2380.1895759999998 ,
2385.1995760000004 ,
2390.209576 ,
2395.209576 ,
2400.219576 ,
2405.229576 ,
2410.239576 ,
2415.2495759999997 ,
2420.259576 ,
2425.2695759999997 ,
2430.269576 ,
2435.279576 ,
2440.289576 ,
2445.299576 ,
2450.309576 ,
2455.319576 ,
2460.329576 ,
2465.339576 ,
2470.3395760000003 ,
2475.349576 ,
2480.3595760000003 ,
2485.369576 ,
2490.379576 ,
2495.389576 ,
2500.399576
)
wavelength_units <- "Nanometers"
wavelength_line <- paste("wavelength = {", paste(wavelength_values, collapse = " , "), "}")
units_line <- paste("wavelength units =", wavelength_units)
# ===============================================================================
# Append wavelength information to the .hdr file
if (file.exists(rectified_hdr_file_path)) {
# Read the existing content of the .hdr file
hdr_content <- readLines(rectified_hdr_file_path)
# Append the wavelength information at the end of the file
hdr_content <- c(hdr_content, units_line, wavelength_line)
# Write the updated content back to the .hdr file
writeLines(hdr_content, rectified_hdr_file_path)
cat("Wavelength information successfully added to the .hdr file.\n")
} else {
cat("Error: The .hdr file does not exist. Check the file path.\n")
}
# clean environment
rm(list=ls(all=TRUE));gc()
graphics.off()
library(terra)
# Read in hyperspectral image
base_path <- getwd()
file_name <- 'ang20190712t231624_rfl_v2v2_img_rectified'
cell <- paste0(base_path,'/data/rectified/',file_name)
tile <- rast(file.path(cell))
# Plot the RGB image for a quick check
plot(ext(tile))
plotRGB(tile, add=T, r=54, g=36, b=20, stretch="lin")
# Calculate the mean of a few values of the near infrared bands (used for NDWI and SAVI)
NIR_average <- mean(tile[[c(86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105)]])
# Calculate green band averages (used for NDWI)
green_average <- mean(tile[[c(26, 27, 28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45)]])
# Calculate red band averages (used for SAVI)
red_average <- mean(tile[[c(56, 57, 58, 59, 60, 61, 62, 63, 64, 65)]])
# Plot histogram of the distribution of the values
hist(NIR_average, breaks = seq(terra::minmax(NIR_average)[1], terra::minmax(NIR_average)[2] + 0.05, by = 0.01),
main = "Histogram of NIR average", xlab = "NIR_average")
################################################################################
# Create NDWI Mask NDWI = (Red - NIR) / (Red + NIR)
################################################################################
# Calculate the NDWI
NDWI <- (green_average-NIR_average)/(green_average+NIR_average)
# Plot histogram of the value distribution
hist(NDWI, breaks = seq(terra::minmax(NDWI)[1], terra::minmax(NDWI)[2] + 0.05, by = 0.01),
main = "Histogram of NDWI", xlab = "NDWI")
# Create the NDWI mask (binary values) with a threshold of 0.1
ndwi_threshold <- 0.1
ndwi_mask <- ifel(NDWI>ndwi_threshold, 0, 1)
# Plot the NDWI mask
plot(ndwi_mask, main = "NDWI Mask")
# Set value 0 to NA to exclude the unwanted pixels
ndwi_mask <- ifel(ndwi_mask==0, NA, 1)
# If desired, save the NDWI mask to a file
ndwi_threshold_modified <- gsub("\\.", "", ndwi_threshold)
ndwi_filename <- paste0("mask/ndwi_mask_",ndwi_threshold_modified)
writeRaster(ndwi_mask, filename = file.path(ndwi_filename),
filetype = "ENVI",
gdal = "INTERLEAVE=BSQ",
overwrite = TRUE,
datatype = "INT1U")
################################################################################
# Create NDVI Mask NDVI = (NIR - Red) / (NIR + Red)
################################################################################
# Calculate the NDVI
NDVI <- (NIR_average-red_average)/(NIR_average+red_average)
# Plot histogram of the value distribution
hist(NDVI, breaks = seq(terra::minmax(NDVI)[1], terra::minmax(NDVI)[2] + 0.05, by = 0.01),
main = "Histogram of NDVI", xlab = "NDVI")
# Create the NDVI mask (binary values) with a threshold of 0.1
ndvi_threshold <- 0.3
ndvi_mask <- ifel(NDVI>ndvi_threshold, 1, 0)
# Plot the NDVI mask
plot(ndvi_mask, main = "NDVI Mask")
# Set value 0 to NA to exclude the unwanted pixels
ndvi_mask <- ifel(ndvi_mask==0, NA, 1)
# If desired, save the NDVI mask to a file
ndvi_threshold_modified <- gsub("\\.", "", ndvi_threshold)
ndvi_filename <- paste0("mask/ndvi_mask_",ndvi_threshold_modified)
writeRaster(ndvi_mask, filename = file.path(ndvi_filename),
filetype = "ENVI",
gdal = "INTERLEAVE=BSQ",
overwrite = TRUE,
datatype = "INT1U")
################################################################################
# Create SAVI Mask SAVI = ((NIR - Red) / (NIR + Red + L)) * (1 + L)
################################################################################
# Set the L parameter for SAVI
L <- 0.5
# Calculate the SAVI
SAVI <- ((NIR_average - red_average) * (1 + L)) / (NIR_average + red_average + L)
# Plot a histogram of the SAVI values to inspect the distribution
hist(SAVI, breaks = seq(terra::minmax(SAVI)[1], terra::minmax(SAVI)[2] + 0.05, by = 0.01),
main = "Histogram of SAVI", xlab = "SAVI")
# Create a SAVI mask (e.g., thresholding SAVI to identify vegetation)
# This threshold can be adjusted based on your analysis needs
savi_threshold <- 0.2
savi_mask <- ifel(SAVI > savi_threshold, 1, 0)  # Here, 0.2 is an example threshold
# Plot the SAVI mask
plot(savi_mask, main = "SAVI Mask")
# Set value 0 to NA to exclude the unwanted pixels
savi_mask <- ifel(savi_mask==0, NA, 1)
# If desired, save the SAVI mask to a file
savi_threshold_modified <- gsub("\\.", "", savi_threshold)
savi_filename <- paste0("mask/savi_mask_",savi_threshold_modified)
writeRaster(savi_mask, filename = file.path(savi_filename),
filetype = "ENVI",
gdal = "INTERLEAVE=BSQ",
overwrite = TRUE,
datatype = "INT1U")
################################################################################
# Create stacked Mask
################################################################################
mask <- mosaic(savi_mask, ndwi_mask, ndvi_mask, fun="min")
plot(mask)
mask <- ifel(mask==0, NA, 1)
# Now write the raster file
writeRaster(mask, filename = file.path("mask/mask_stack"),
filetype = "ENVI",
gdal = "INTERLEAVE=BSQ",
overwrite = TRUE,
datatype = "INT1U")
# clean environment
rm(list=ls(all=TRUE));gc()
graphics.off()
# load biodivMapR and useful libraries
library(biodivMapR)
library(labdsv)
library(tools)
library(ggplot2)
library(gridExtra)
library(terra)
# ===============================================================================
# set important variables
base_path <- getwd()
# clean environment
rm(list=ls(all=TRUE));gc()
graphics.off()
# load biodivMapR and useful libraries
library(biodivMapR)
library(labdsv)
library(tools)
library(ggplot2)
library(gridExtra)
library(terra)
# ===============================================================================
# set important variables
base_path <- getwd()
# input image folder path rectified
Datadir <- paste0(base_path,'/data/rectified')
# name of the image file
NameRaster <- 'ang20190712t231624_rfl_v2v2_img_rectified'
Input_Image_File <- file.path(Datadir,NameRaster)
Input_HDR_File <- get_HDR_name(Input_Image_File,showWarnings = FALSE)
dir.create(path = Datadir,recursive = T,showWarnings = F)
################################################################################
##                      Set parameters for biodivMapR                         ##
## https://jbferet.github.io/biodivMapR/articles/biodivMapR_2.html            ##
################################################################################
# Define path for image file to be processed
# Define path for corresponding mask file
# Set to FALSE if no mask available
#Input_Mask_File <- FALSE
Input_Mask_File <- paste0(base_path,'/mask/savi_mask_02')
# Define path for master output directory where files produced during the process are saved
# Master output directory (remove unnecessary line break)
Output_Dir <- paste0(base_path,'/result')
dir.create(path = Output_Dir, recursive = TRUE, showWarnings = FALSE)
dir.create(path = Output_Dir,recursive = T,showWarnings = F)
# Define levels for radiometric filtering
NDVI_Thresh <- 0.3
Blue_Thresh <- 500
NIR_Thresh <- 1500
# Apply normalization with continuum removal?
Continuum_Removal <- FALSE
# Type of dimensionality reduction
TypePCA <- 'SPCA'
# PCA FILTERING:        Set to TRUE if you want second filtering based on PCA outliers to be processed.
# Slower process
# Automatically set to FALSE if TypePCA     = 'MNF'
FilterPCA <- FALSE
# window size forcomputation of spectral diversity
window_size <- 10
# computational parameters
nbCPU <- 8
MaxRAM <- 8
# number of clusters (spectral species)
nbclusters <- 20
# set excluding wavelengths --> either "FALS" or some wavelengths
#Excluded_WL = FALSE
# bblist[0:14] = 0
# bblist[189:225] = 0
# bblist[281:336] = 0
# bblist[405:] = 0
#
Excluded_WL <- c(0, 442)
Excluded_WL <- rbind(Excluded_WL, c(1368, 1499))
Excluded_WL <- rbind(Excluded_WL, c(1779, 2055))
Excluded_WL <- rbind(Excluded_WL, c(2400, 2501))
print("PERFORM DIMENSIONALITY REDUCTION")
#debug(perform_PCA)
PCA_Output <- perform_PCA(Input_Image_File = Input_Image_File,
Input_Mask_File = Input_Mask_File,
Output_Dir = Output_Dir,
TypePCA = TypePCA,
FilterPCA = FilterPCA,
Excluded_WL = Excluded_WL,
nbCPU = nbCPU,
MaxRAM = MaxRAM,
Continuum_Removal = Continuum_Removal)
# path for the updated mask
Input_Mask_File <- PCA_Output$MaskPath
var_exp <- (PCA_Output$PCA_model$sdev^2/sum(PCA_Output$PCA_model$sdev^2))*100
barplot(var_exp, names.arg = colnames(PCA_Output$PCA_model$x))
pca_output_image_file_path = paste0(Output_Dir,"/",NameRaster,"/",TypePCA,"/PCA/","OutputPCA_30_PCs")
print(pca_output_image_file_path)
pca_output_image <- rast(pca_output_image_file_path)
plot(pca_output_image, main = "Principal Components", nc = 5, maxnl = 30)  # maxnl allows all 30 layers to be shown
typeof(PCA_Output)
typeof(PCA_Output$MaskPath)
print(PCA_Output)
print(PCA_Output$PCA_model)
print(PCA_Output)
typeof(PCA_Output)
# Save the list as an RDS file
pca_output_rds_file_path = paste0(Output_Dir,"/",NameRaster,"/",TypePCA,"/PCA/","PCA_Output.rds")
saveRDS(PCA_Output, file = pca_output_rds_file_path)
# Later, load the list back into R
PCA_Output <- readRDS(pca_output_rds_file_path)
# Select components from the PCA/SPCA/MNF raster
# Sel_PC = path of the file where selected components are stored
Sel_PC <- select_PCA_components(Input_Image_File = Input_Image_File,
Output_Dir = Output_Dir,
PCA_Files = PCA_Output$PCA_Files,
TypePCA = PCA_Output$TypePCA,
File_Open = TRUE)
################################################################################
##                  Perform Spectral species mapping                          ##
## https://jbferet.github.io/biodivMapR/articles/biodivMapR_5.html            ##
################################################################################
print("MAP SPECTRAL SPECIES")
Kmeans_info <- map_spectral_species(Input_Image_File = Input_Image_File,
Input_Mask_File = PCA_Output$MaskPath,
Output_Dir = Output_Dir,
SpectralSpace_Output = PCA_Output,
nbclusters = nbclusters,
nbCPU = nbCPU, MaxRAM = MaxRAM)
################################################################################
##                Perform alpha and beta diversity mapping                    ##
## https://jbferet.github.io/biodivMapR/articles/biodivMapR_6.html            ##
################################################################################
print("MAP ALPHA DIVERSITY")
Index_Alpha   = c('Shannon','Simpson')
#Index_Alpha <- c('Shannon')
map_alpha_div(Input_Image_File = Input_Image_File,
Output_Dir = Output_Dir,
TypePCA = TypePCA,
window_size = window_size,
nbCPU = nbCPU,
MaxRAM = MaxRAM,
Index_Alpha = Index_Alpha,
nbclusters = nbclusters)
print("MAP BETA DIVERSITY")
map_beta_div(Input_Image_File = Input_Image_File,
Output_Dir = Output_Dir,
TypePCA = TypePCA,
window_size = window_size,
nbCPU = nbCPU,
MaxRAM = MaxRAM,
nbclusters = nbclusters)
## read selected features from dimensionality reduction
Selected_Features <- read.table(Sel_PC)[[1]]
## path for selected components
map_functional_div(Original_Image_File = Input_Image_File,
Functional_File = PCA_Output$PCA_Files,
Selected_Features = Selected_Features,
Output_Dir = Output_Dir,
window_size = window_size,
nbCPU = nbCPU,
MaxRAM = MaxRAM,
TypePCA = TypePCA)
